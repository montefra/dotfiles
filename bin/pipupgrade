#!/bin/bash
# upgrade packages in .local and in the virtualenvs installed via
# ``virtualenvwrapper``


# list the packages to update. Filters out any line starting with Some or Could
# \param $1: name of the pip code to use
# \return: list of packages to be upgraded
function get_toupdate(){
  to_up=`$1 list -l -o --allow-all-external 2>/dev/null | awk '{print $1}'`
  to_up=${to_up//Could}  # remove Could
  to_up=${to_up//Some}  # remove Some
  to_up=${to_up//You}  # remove Some

  echo $to_up
}

# check if the package is installed in .local/lib
# \param $1: name of the pip code to use
# \param $2: name of the package
# \return: true, if the package is local, false otherwise
function is_local(){
  loc=`$1 show $2 | awk '$1~"Location:" {print $2}'`
  if [[ "$loc" = *local/lib* ]]
  then 
    echo true
  else 
    echo false
  fi
}

# check if the exit code 0 or not
# \param $1: error code
# \param $2: name of the package
function checkexit(){
  if [ $1 -eq 0 ]
  then
    echo -e "Upgrade of $2: \e[1;32msuccess\e[0m"
  else
    echo -e "Upgrade of $2: \e[1;31mfail. Check the log files'\e[0m"
  fi
}

# upgrade the package in .local
# \param $1: mane of pip code to use
# \param $2: package to update
# \param $3: log file name
function update_local(){
  is_l=`is_local $1 $2`
  if [ $is_l = true ]
  then
    echo $2
    $1 install -U --user --allow-all-external $2 >> $3
    checkexit $? $2
  else
    echo To upgrade $2 first re-install it by hand using --user
  fi
}

# upgrade the package in a virtualenv
# \param $1: mane of pip code to use
# \param $2: package to update
# \param $3: log file name
function update_venv(){
  echo $2
  $1 install -U --allow-all-external $2 >> $3
  checkexit $? $2
}

# upgrade all the packages
# \param $1: mane of pip code to use
# \param $2: logfile
function update(){

  if [ -z $VIRTUAL_ENV ]
  then
    echo Upgrading with $1 the following packages
  else
    echo Upgrading packages in venv $VIRTUAL_ENV
  fi

  to_up=`get_toupdate $1`
  echo $to_up
  for tu in $to_up
  do
    if [ -z $VIRTUAL_ENV ]
    then
      update_local $1 $tu $2
    else
      update_venv $1 $tu $2
    fi
  done
}

# if we are in a virtual env, save the name and deactivate
if [ $VIRTUAL_ENV ]
then
  echo "The script does not work properly when launched from a virtual environment"
  exit 5
fi

# log directory
pipdir=$HOME/.pip
mkdir $pipdir 2>/dev/null

# update local packages
log2=$pipdir/pip2_upgrade.log
log3=$pipdir/pip3_upgrade.log

echo Clear old log files
cat /dev/null > $log2
cat /dev/null > $log3

update pip2 $log2
echo ==================== 
update pip3 $log3

# update the virtual environments
# enable workon
source $HOME/.local/bin/virtualenvwrapper.sh
venvs=`workon 2>/dev/null`
if [ $? -lt 1 ]
then
  echo 'workon' not found, is wirtualenvwrapper installed
  exit $?
else
  for v in $venvs
  do
    echo ==================== 
    # activate the venv
    workon $v
    # create the log file
    logf=$pipdir/pip${v}_upgrade.log
    cat /dev/null > $logf
    update pip $logf
  done
fi
